package glui

import (
	"github.com/go-gl/glfw/v3.3/glfw"
	"math"
)

const (
	DefaultClickLimit = 2
)

var (
	ClickLimit float64 = DefaultClickLimit // Max allowed distance between press and release
)

// MouseClickListener adds some processing to the mouse button press and release events generated by glfw
// to turn them into single click events at the point the button was first pressed.
type MouseClickListener struct {
	Window    *GLWin
	Button    MouseButton
	Point     []float64
	Observers []func(point []float64)
}

// NewMouseClickListener adds a listener to the supplied window for the indicated button,
// and the function to be called when a click is detected.
func NewMouseClickListener(win *GLWin, button MouseButton, onClick func([]float64)) *MouseClickListener {
	res := &MouseClickListener{win, button, nil, []func([]float64){onClick}}
	win.Win.SetMouseButtonCallback(func(w *glfw.Window, but MouseButton, act Action, mods glfw.ModifierKey) {
		if but != res.Button {
			return
		}
		if act == Press {
			x, y := w.GetCursorPos()
			res.Point = []float64{x, y}
		} else if act == Release {
			if res.Point == nil {
				return
			}
			// Check release point is within thresh of res.Point
			x, y := w.GetCursorPos()
			dx, dy := res.Point[0]-x, res.Point[1]-y
			d := math.Hypot(dx, dy)
			if d > ClickLimit {
				res.Point = nil
				return
			}
			// Call observers with mouse click
			for _, ocf := range res.Observers {
				if ocf == nil {
					continue
				}
				go ocf(res.Point)
			}
			res.Point = nil
		}
	})
	return res
}

// MouseDragListener adds some processing to the mouse button press and release events generated by glfw
// to turn them into a sequence of drag events from the point the button was first pressed until it is released.
type MouseDragListener struct {
	Window    *GLWin
	Button    MouseButton
	Observers []func(point []float64, dx, dy float64, act Action)
	Point     []float64
	State     bool
}

// NewMouseDragListener adds a listener to the supplied window for the indicated button,
// and the function to be called when a drag occurs.
func NewMouseDragListener(win *GLWin, button MouseButton, onDrag func([]float64, float64, float64, Action)) *MouseDragListener {
	res := &MouseDragListener{win, button, []func([]float64, float64, float64, Action){onDrag}, nil, false}
	win.Win.SetMouseButtonCallback(func(w *glfw.Window, but MouseButton, act Action, mods glfw.ModifierKey) {
		if but != res.Button {
			return
		}
		x, y := w.GetCursorPos()
		pt := []float64{x, y}
		var dx, dy float64
		if act == Press {
			res.State = true
			res.Point = []float64{x, y}
		} else if act == Release {
			if !res.State {
				return
			}
			dx, dy = x-res.Point[0], y-res.Point[1]
			res.State = false
		}
		// Call observers with mouse click
		for _, ocf := range res.Observers {
			if ocf == nil {
				continue
			}
			go ocf(pt, dx, dy, act)
		}
		res.Point = pt
	})
	win.Win.SetCursorPosCallback(func(w *glfw.Window, x, y float64) {
		if !res.State {
			return
		}
		pt := []float64{x, y}
		dx, dy := x-res.Point[0], y-res.Point[1]
		// Call observers with mouse click
		for _, odf := range res.Observers {
			if odf == nil {
				continue
			}
			go odf(pt, dx, dy, Repeat)
		}
		res.Point = pt
	})

	return res
}

// MouseMoveListener is a wrapper around the cursor position callback.
type MouseMoveListener struct {
	Window    *GLWin
	Observers []func(point []float64)
}

// NewMouseMoveListener adds a listener to the supplied window,
// and the function to be called when mouse movement occurs.
func NewMouseMoveListener(win *GLWin, onMove func([]float64)) *MouseMoveListener {
	res := &MouseMoveListener{win, []func([]float64){onMove}}
	win.Win.SetCursorPosCallback(func(w *glfw.Window, x, y float64) {
		pt := []float64{x, y}
		// Call observers with mouse position
		for _, omf := range res.Observers {
			if omf == nil {
				continue
			}
			go omf(pt)
		}
	})

	return res
}

// MouseScrollListener is a wrapper around the mouse scroll callback.
type MouseScrollListener struct {
	Window    *GLWin
	Observers []func(dx, dy float64)
}

// NewMouseScrollListener adds a listener to the supplied window,
// and the function to be called when mouse movement occurs.
func NewMouseScrollListener(win *GLWin, onScroll func(float64, float64)) *MouseScrollListener {
	res := &MouseScrollListener{win, []func(float64, float64){onScroll}}
	win.Win.SetScrollCallback(func(w *glfw.Window, dx, dy float64) {
		// Call observers with mouse scroll
		for _, omf := range res.Observers {
			if omf == nil {
				continue
			}
			go omf(dx, dy)
		}
	})

	return res
}
