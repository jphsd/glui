package glui

import (
	"github.com/go-gl/glfw/v3.3/glfw"
	"math"
)

const (
	DefaultClickLimit = 2
)

var (
	ClickLimit float64 = DefaultClickLimit // Max allowed distance between press and release
)

// MouseClickListener adds some processing to the mouse button press and release events generated by glfw
// to turn them into single click events at the point the button was first pressed.
type MouseClickListener struct {
	Window    *GLWin
	Button    glfw.MouseButton
	Point     []float64
	Observers []func(point []float64)
}

// NewMouseClickListener adds a listener to the supplied window for the indicated button,
// and the function to be called when a click is detected.
func NewMouseClickListener(win *GLWin, button glfw.MouseButton, onClick func([]float64)) *MouseClickListener {
	res := &MouseClickListener{win, button, nil, []func([]float64){onClick}}
	win.Win.SetMouseButtonCallback(func(w *glfw.Window, but glfw.MouseButton, act Action, mods glfw.ModifierKey) {
		if but != res.Button {
			return
		}
		if act == Press {
			x, y := w.GetCursorPos()
			res.Point = []float64{x, y}
		} else if act == Release {
			if res.Point == nil {
				return
			}
			// Check release point is within thresh of res.Point
			x, y := w.GetCursorPos()
			dx, dy := res.Point[0]-x, res.Point[1]-y
			d := math.Hypot(dx, dy)
			if d > ClickLimit {
				res.Point = nil
				return
			}
			// Call observers with mouse click
			for _, ocf := range res.Observers {
				if ocf == nil {
					continue
				}
				ocf(res.Point)
			}
			res.Point = nil
		}
	})
	return res
}

// MouseDragListener adds some processing to the mouse button press and release events generated by glfw
// to turn them into a sequence of drag events from the point the button was first pressed until it is released.
type MouseDragListener struct {
	Window    *GLWin
	Button    glfw.MouseButton
	Observers []func(point []float64, act Action)
	State     bool
}

// NewMouseDragListener adds a listener to the supplied window for the indicated button,
// and the function to be called when a drag occurs.
func NewMouseDragListener(win *GLWin, button glfw.MouseButton, onDrag func([]float64, Action)) *MouseDragListener {
	res := &MouseDragListener{win, button, []func([]float64, Action){onDrag}, false}
	win.Win.SetMouseButtonCallback(func(w *glfw.Window, but glfw.MouseButton, act Action, mods glfw.ModifierKey) {
		if but != res.Button {
			return
		}
		x, y := w.GetCursorPos()
		if act == Press {
			res.State = true
		} else if act == Release {
			if !res.State {
				return
			}
			res.State = false
		}
		pt := []float64{x, y}
		// Call observers with mouse click
		for _, ocf := range res.Observers {
			if ocf == nil {
				continue
			}
			ocf(pt, act)
		}
	})
	win.Win.SetCursorPosCallback(func(w *glfw.Window, x, y float64) {
		if !res.State {
			return
		}
		pt := []float64{x, y}
		// Call observers with mouse click
		for _, odf := range res.Observers {
			if odf == nil {
				continue
			}
			odf(pt, Repeat)
		}
	})

	return res
}
